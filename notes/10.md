# Function Definitions, Calls, Arguments, and Types

We are almost ready to try our primality test program. The biggest remaining feature is functions, illustrated by the following script:

```py
def f(x: int) -> int:
    return x + 10

f(10)
```

Luckily, the lexing stage already works perfectly for this example. We move on to parsing.

## Parsing

We start with the new AST nodes: [`funcdef`,](https://docs.python.org/3.13/reference/compound_stmts.html#grammar-token-python-grammar-funcdef) [`parameter_list`,](https://docs.python.org/3.13/reference/compound_stmts.html#grammar-token-python-grammar-parameter_list) and [`defparameter`](https://docs.python.org/3.13/reference/compound_stmts.html#grammar-token-python-grammar-defparameter) for the function definition. As well as the [`return_stmt`](https://docs.python.org/3.13/reference/simple_stmts.html#grammar-token-python-grammar-return_stmt) and [`call`](https://docs.python.org/3.13/reference/expressions.html#grammar-token-python-grammar-call) nodes for other parts of the program.

We are simplifying `funcdef` nodes somewhat by flattening/inling parts of the definition. We might elaborate on them later. We are also ignoring various parts related to type arguments for generic functions, keyword parameters, etc.

Now we implement all the parsing methods. Everything is pretty straightforward. The only thing of note is the recursive nature of the definition for `call`—it is a `primary` node which itself starts with a `primary` child, so we cannot implement it recursively. Instead, we parse the `atom`-containing part of the primary as usual, then consume all follow-up parentheses indicating a call, iteratively wrapping the result in new `call` nodes.

We also run into a quirk of the Python grammar. Since empty lines produce an `nl` token, distinct from a `whitespace` token, we end up needing to explicitly handle it in the parts of the grammar that read lists of statements. To parse the current example, we need to skip all `nl` tokens before an expected `dedent` in the body of the `suite` parser.

With this changes, the example parses.

## Interpretation

Function definition statements simply bind the function name to its AST node. To implement function calls, we begin by recognizing that we will need to keep a distinct set of local variables for each function. We rename our `Interpreter` class to `Scope`. We add a `resolve` function for finding the value of a variable, which raises an error if the variable is not found (this will be ammended further to support closures in the future). Function calls can now create a new scope, populate it with argument values, then evaluate the function body within this scope to get the result.

To support return statements, we need to supporting aborting the interpretation of a block of statements and forcing the evaluation function to yield a result to the caller. The simplest way to implement this is to use Python exceptions to bubble the return value up to a handler waiting inside the function call interpreter.

## Compilation

Let's begin by changing our local variable tracking like we did for the interpreter. We rename `Compiler` to `Scope` in anticipation of compiling functions with their own custom set of local variables. We make a new `Compiler` class that holds a list of scopes so we can emit the definition of every function we use. It will also be responsible for generating unique names for our scopes using an incrementing index.

When we encounter a function definition, we create a new scope, register it with the `Compiler` instance, and ask it to emit a new function definition (using the new `compile_func_body` method). Because Python is a dynamically typed language, we do not know in advance what signature any function value has, so calling any function should be possible with the same generic code, meaning all functions need to have the same LLVM type. In our implementation we use `i64` as the return value and a `i64* %args` parameter containing a pointer to a caller-allocated array, the members of which are individual parameters.

The function body thus has to start with taking the parameters out of the `%args` array and placing them in local variables. The function call is the reverse of this operation—allocating the `%args` array on the stack and storing the values in it before making the function call.

An alternative to our parameter array approach might be to use LLVM's `var_arg` feature explicitly designed for variadic functions. Potential improvements include [lifetime annotations](https://llvm.org/docs/LangRef.html#memory-use-markers) and using type inference to emit specialized function definitions and calls.

Return statements simply translate to the `ret` instruction.

Let's look at the final code output:

```llvm
define i64 @module_root() {
  start:
  ; def f(x: int) -> int:
  ;     return x + 10
  ;
  %f.1 = bitcast ptr @f.0 to ptr
  ; f(10)
  %call.args.2 = alloca i64, i64 1
  ; 10
  %_const.3 = bitcast i64 10 to i64
  %call.args.0.4 = getelementptr i64, ptr %call.args.2, i64 0
  store i64 %_const.3, i64* %call.args.0.4

  %call.res.5 = call i64 %f.1(i64* %call.args.2)
  ret i64 %call.res.5
}

define i64 @f.0(ptr %args) {
  start:
  %arg.offset.x.2 = getelementptr i64, ptr %args, i64 0
  %x.1 = load i64, ptr %arg.offset.x.2
  ; return x + 10
  ; x + 10
  %_const.3 = bitcast i64 10 to i64
  %_aexpr.4 = add i64 %x.1, %_const.3
  ret i64 %_aexpr.4
}

module_root() = 20
```

`%f.1 = bitcast ptr @f.0 to ptr` stores the function pointer in the local variable `f`.

`%call.args.2 = alloca i64, i64 1` allocates the argument array. It is followed by `%call.args.N.*` variables for each argument which calculate the address at which the argument should be written to with the following `store` instruction.

`%call.res.5 = call i64 %f.1(i64* %call.args.2)` is the actual function call, passing just the argument array `%call.args.2` to the function `store`d in register `%f.1`

`define i64 @f.0(ptr %args) {` is the start of the actual definition of `f`. The first line of the definition computes the memory location (`%arg.offset.x.*`) for each argument so they can be `load`ed from `%args`.

Note the use of opaque pointers (`ptr`) over specific pointer types as [the latter are deprecated.](https://llvmlite.readthedocs.io/en/stable/user-guide/deprecation.html#deprecation-of-typed-pointers)
