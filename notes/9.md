# While Loops

We are going to use the following source string as our test case:

```python
a = 2
while a <= 10:
    a = a * a
a
```

Lexing just works!

To parse, we just add [the `while_stmt` node,](https://docs.python.org/3.13/reference/compound_stmts.html#grammar-token-python-grammar-while_stmt) and implement it in exactly the same way as `if_stmt`. We also need to support `<=` for `Comparison` nodes.

To interpret, we add the `WhileStmt` handler, and update the conditional handler to support `<=`.

## Compiling

The while loop can be desugarred to an `if` statement and a go-to. In pseudocode:

```
while (condition):
  # loop body
  ...

# becomes

# >>> loop
if not (condition):
  goto end

# loop body
...

goto loop

# >>> end

```

In LLVM IR this looks roughly like this:

```llvm
...

; blocks must have an explicit end instruction
; they will not automatically run the next block as in other languages like assembly
br label %loop

loop:

; calculate the condition as i1
%cond = ...
br i1 %cond, label %loop_body, label %loop_end

loop_body:
...

br label %loop

loop_end:
...

```

When we implement this as is, we will get the same `Instruction does not dominate all uses` issue as with `if` statements. Consider the following example:

```llvm
define i64 @test() {
  start:
  ; a = 2
  %.2 = bitcast i64 2 to i64
  %a.1 = bitcast i64 %.2 to i64

  ; while a <= 10:
  ;     a = a * a
  br label %while.cond.3

  while.cond.3:
  %_compare.5 = bitcast i1 1 to i1
  %.6 = bitcast i64 10 to i64
  %.9 = icmp sle i64 %a.1, %.6
  %_eq.7 = and i1 %_compare.5, %.9
  %_compare.res.10 = zext i1 %_eq.7 to i64
  %while.cond.i1.11 = icmp eq i64 %_compare.res.10, 1
  br i1 %while.cond.i1.11, label %while.loop.4, label %while.end.12

  while.loop.4:
  ; a = a * a
  %.14 = mul i64 %a.13, %a.13
  %a.13 = bitcast i64 %.14 to i64

  br label %while.cond.3

  while.end.12:

  ; a

  ret i64 %a.13
}
```

which fails with

```
Instruction does not dominate all uses!
  %a.13 = bitcast i64 %.14 to i64
  %.14 = mul i64 %a.13, %a.13
Instruction does not dominate all uses!
  %a.13 = bitcast i64 %.14 to i64
  %.14 = mul i64 %a.13, %a.13
Instruction does not dominate all uses!
  %a.13 = bitcast i64 %.14 to i64
  ret i64 %a.13
```

The most obvious problem (since we've seen it with `if`) is that the return statement uses `%a.13` which is defined in the loop body, which may run 0 times depending on the condition. The solution, however is different. In this case the control flow only ever reaches `%while.end.12` from the `%while.cond.3` block so a `phi` instruction would be useless. Instead, we need to make sure that any variables modified in the loop body are rolled-back to the binding the used at the end of the loop conditional. The challenge is, to figure out which variables we have to rollback, we need to run through the loop body and collect their names. Since we are compiling the body anyway, let's simply compare the `self.locals` bindings before and after the `while.loop` block:

```python
...
self.emit(f"br label %{loop_cond_label}")

self.emit_block(loop_cond_label)
cond = self.compile_expr(x.cond)
...
post_cond_locals = copy(self.locals)
self.emit(f"br i1 %{cond_i1}, label %{loop_label}, label %{end_label}")

self.emit_block(loop_label)
self.compile(x.loop)
self.emit(f"br label %{loop_cond_label}")

self.emit_block(end_label)
self.emit("")
for k, prev in post_cond_locals.items():
    new = self.locals[k]
    if prev == new:
        continue

    self.locals[k] = prev

return
```

This produces `ret i64 %a.1` in the return, which is valid since it comes from the `start` block that always runs.

We still have a problem from before regarding the usage of `a.13` and `.14` in the `while.loop` block:

```llvm
%.14 = mul i64 %a.13, %a.13
%a.13 = bitcast i64 %.14 to i64
```

These two definitions are mutually recursive so they cannot compile. The problem is in our implementation of assignment. We immediately change the binding of `a` to the newly allocated variable `a.13` before we emit its value computation. This means that when a variable is assigned to an expression that mentions itself, we end up using the new not-yet-bound variable name. The fix is to simply only set `self.locals` after the corresponding `%{name} = ...` instructions is emitted.

With this change the body of the loop compiles:

```llvm
%.14 = mul i64 %a.1, %a.1
%a.13 = bitcast i64 %.14 to i64
```

---

When we try to run the generated code, the program will hang (it enters an infinite loop). To figure out why, we look at the generated code after all our previous patches:

```llvm
define i64 @test() {
  start:
  ; a = 2
  %.2 = bitcast i64 2 to i64
  %a.1 = bitcast i64 %.2 to i64

  ; while a <= 10:
  ;     a = a * a
  br label %while.cond.3

  while.cond.3:
  %_compare.5 = bitcast i1 1 to i1
  %.6 = bitcast i64 10 to i64
  %.9 = icmp sle i64 %a.1, %.6
  %_eq.7 = and i1 %_compare.5, %.9
  %_compare.res.10 = zext i1 %_eq.7 to i64
  %while.cond.i1.11 = icmp eq i64 %_compare.res.10, 1
  br i1 %while.cond.i1.11, label %while.loop.4, label %while.end.12

  while.loop.4:
  ; a = a * a
  %.14 = mul i64 %a.1, %a.1
  %a.13 = bitcast i64 %.14 to i64

  br label %while.cond.3

  while.end.12:

  ; a

  ret i64 %a.1
}
```

We are expecting the loop to terminate when the value of `a` exceeds `10` but variables in LLVM IR are immutable, so the value of `a` will never change without dedicated effort. This is easy to see in the code: the condition looks at `%a.1` but the loop assigns `a.13`—they never interact in any way.

To fix this, we need to use a `phi` instruction. The `while.cond` block is entered either from `start` (in which case we want to use `a.1`) or from `while.loop` in which case we want to use the new value, `a.13`. Essentially we want to add `%a.test = phi i64 [ %a.1, %start ], [ %a.13, %while.loop.4 ]` and rebind `a` to point to it.

There are a few parts to this process:

1. we have to know which variables to process—in general these are the values that are read in the `while.cond` block and written in the `while.loop` block,
2. we need the bindings of these variables after `while.loop` so we can include them in the `phi` instruction,
3. the `while.loop` block has to use the `phi`-bound variable bindings so it also uses values from previous iterations. This last part actually broadens our concern to additionally include variables that are both read and written by the loop body. And, if you think about it further, other variables may be read after the loop body, so we should really `phi` _all_ the variables written by the loop.

It is not super obvious, but there is a problem. The loop body requires the `phi`-bound variables, generating which requires knowing the set of variables that are modified in the loop body. This is a circular dependency, so we need to cut it somehow. One way would be to `phi` all the variables but there can be very many and it would produce awful IR. Instead, we need to compute which variables the loop will write before we emit it. There are cheaper ways of doing this, but for now we just `deepcopy` the compiler, emit the loop body, take the new `locals` value from the copy, and throw it out.

There is a second circular dependency too—we need to know what the final name of all the bindings are after the loop body when we generate the `phi`s. The copy of the compiler will not help us here because it will end up with different identifiers as we will allocate additional identifiers before the body when we generate it for real. Instead, we will allocate special "loop end" variables that we will copy the final result into at the end of the loop body.

Rough outline of all the new code:

```python
...

lookahead_compiler = deepcopy(self)
lookahead_compiler.compile(x.loop)
lookahead_locals = lookahead_compiler.locals
del lookahead_compiler

loop_modified_locals: set[str] = set()
for k, prev in prev_locals.items():
    la = lookahead_locals[k]
    if prev == la:
        continue

    loop_modified_locals.add(k)

loop_end_locals: dict[str, str] = {}
for k in loop_modified_locals:
    loop_end_locals[k] = self.next_id(prefix=f"while.local.{k}")

# >>> while.cond
self.emit_block(loop_cond_label)
for k in loop_modified_locals:
    var = self.next_id(prefix=k)

    prev = prev_locals[k]
    new = loop_end_locals[k]

    self.emit(
        f"%{var} = phi i64 [ %{prev}, %{prev_block} ], [ %{new}, %{loop_label} ]"
    )
    self.locals[k] = var

# >>> while.loop
self.emit_block(loop_label)
self.compile(x.loop)

for k, new in loop_end_locals.items():
    self.emit(f"%{new} = bitcast i64 %{self.locals[k]} to i64")

...

# >>> while.end
self.emit_block(end_label)
self.emit("")
for k, prev in post_cond_locals.items():
    new = self.locals[k]
    if prev == new:
        continue

    self.locals[k] = prev

return
```

This produces the following output:

```llvm
define i64 @test() {
  start:
  ; a = 2
  %.2 = bitcast i64 2 to i64
  %a.1 = bitcast i64 %.2 to i64

  ; while a <= 10:
  ;     a = a * a
  br label %while.cond.3

  while.cond.3:
  %a.6 = phi i64 [ %a.1, %start ], [ %while.local.a.5, %while.loop.4 ]
  %_compare.7 = bitcast i1 1 to i1
  %.8 = bitcast i64 10 to i64
  %.11 = icmp sle i64 %a.6, %.8
  %_eq.9 = and i1 %_compare.7, %.11
  %_compare.res.12 = zext i1 %_eq.9 to i64
  %while.cond.i1.13 = icmp eq i64 %_compare.res.12, 1
  br i1 %while.cond.i1.13, label %while.loop.4, label %while.end.14

  while.loop.4:
  ; a = a * a
  %.16 = mul i64 %a.6, %a.6
  %a.15 = bitcast i64 %.16 to i64

  %while.local.a.5 = bitcast i64 %a.15 to i64
  br label %while.cond.3

  while.end.14:

  ; a

  ret i64 %a.6
}
```
