# Compiling `is_prime`

Now that we can successfully lex, parse, interpret, and compile all the elements of the `is_prime` program, the next step is to ensure we can deal with it directly.

## Parsing

We remove the early return from `test_parse.py` after the smoketest.

The first error is unexpected whitespace within the block of the function:

```
vpy.parse.ParseFailedError: expected <dedent>, found <whitespace>
Parse function: suite
Parse function: funcdef
Parse function: compound_stmt
Parse function: statement
Parse function: file_input

    if x % 2 == 0:
    ^
```

This is quite confusing since the arrow clearly points at the `if` keyword (or the indent right before it). Is the unexpected whitespace token empty? We add the current token to the output of the error message, which becomes `vpy.parse.ParseFailedError: expected <dedent>, found <whitespace> (whitespace@5:1#66'    ')` (and repeat this for all the `expect_*` methods).

The token is not empty, rather it contains the four whitespaces that we assumed were part of the indent. Surprisingly, this is not a bug in the lexer. Instead of emitting indentation tokens for all present indentation, Python chooses to emit indentation tokens only when the level must change. Since the Python grammar ignores whitespace, it makes no special provision for indentation which does not change the level but rather maintains it. In our case, we must explicitly consume the whitespace between statements in the `suite` parse function. A `<dedent>` token will not match, so the `suite` node will end correctly.

To further clarify why this is a `<whitespace>` token, consider the tokens and indentation levels in the following example:

```py
def f(): # ilevel (indent level) = 0
    x = 10 # <indent "    "> (ilevel = 1) x = 10
    x = 25 # <whitespace "    "> (ilevel = 1) x = 25
# <dedent> (ilevel = 0)
```

---

Fixing this, we get a new error and remember that `Suite` nodes do not actually support having more than one child, as indicated by an assertion we've put in.

The problem is that we'd like to return `list[ast.stmt]` from the `to_ast` method, but this is not a subclass of `ast.AST` so it conflicts with the prototype in the base `Node` class. Thankfully, we can simply remove the method from the prototype and let the type checker verify that all the necessary classes still implement it and the types lines up.

In addition to patching `Suite`, we make a similar change in `StmtList`. And, to support the new list-of-statement values, we adjust `IfStmt`, `WhileStmt`, `Statement`, and `FileInput`; all of which contain either `Suite` or `StmtList` children.

Now the file parses correctly.

## Interpreting

No changes necessary! Just add the file to the test harness and with the work from the prior chapters, the program interprets correctly.

Note: to allow for testing the return value, we add a call to the solution function to the test file.

## Compiling

We load the source into `test_compile.py`, and see an LLVM error:

```
RuntimeError: PHI node entries do not match predecessors!
```

This is due to the body of the loop containing an `if` statement, which introduces another code block. When we insert the conditional branch at the end of the loop, we insert it right after `self.compile(x.loop)`, so it gets placed within the block created by the `if`. This means that the `while` loop is now the jump target of the `if` block rather than itself.

The solution is to introduce a custom loop epilogue block after the loop body. The loop body will uncoditionally jump to the epilogue, which will conditionally restart the loop.

After this change, the program correctly compiles and gives us the expected results. Test with multiple values of the argument to see that the result is `1` for prime numbers and `0` otherwise.

## Cleanup & Refactoring

Before we move on, we will take some time to clean up and refactor the code.

One annoyance with the parsing code is having to specify the type string for each AST node, despite the type being implicit in the class name.

We convert the `type` field into a getter property, which we make into an abstract method via [`abc.ABC`.](https://docs.python.org/3/library/abc.html#abc.ABC) Each AST class gets adjusted accordingly, and the parsing functions no longer set type strings on the nodes.

---

We also remove `Parser.token_stack` since it has actually been unused since after our switch to using lexer checkpoints in part 6.

---

Finally, as an aside, we add a `--reference` flag to the `vpy parse` command which will output the Python standard libary AST rather than the vpy AST. This is a useful generic debugging utility.

## Greatest Common Divisor

Supporting a real program is a big achievement, so let's celebrate by adding another test caseâ€”problem 2.07, which requires us to use Euclid's algorithm to determine the GCD of two numbers.

We write the solution and realize that all the required features are already implemented. And, indeeed, the program lexes, parses, and interprets without any further changes.

Compilation, however, fails with the following error:

```
RuntimeError: LLVM IR parsing error
<string>:117:1: error: expected instruction opcode
```

This is because there is no operation after our while loop. Now, we know that the `while True` loop code will never reach the `while.end` block, so whether it contains an instruction is irrelevant, but this is not encoded in the LLVM IR. We fix this by recognizing that, lacking an explicit return, a Python function retuns `None`, which we will simply encode as `0` since we do not yet support any types other than `i64`. We append a `ret i64 0` to the end of every function body (it is harmless if there is an explicit return that preceeds it).

After this, the GCD problem is also fully supported.
